[
    {
        "type": "multiple",
        "question": "¿Cuál es la función principal del archivo joinfiles.py?",
        "options": [
            "Consolidar archivos .py en un solo archivo de texto",
            "Dividir un archivo de texto en múltiples archivos .py",
            "Eliminar archivos .py en un directorio",
            "Renombrar archivos .py en un directorio"
        ],
        "answer": 0,
        "explanation": "El archivo joinfiles.py recorre un directorio y consolida todos los archivos .py en un solo archivo de texto, agrupándolos por carpeta y archivo."
    },
    {
        "type": "fill",
        "question": "En scrap.py, la función _____ verifica si una URL es válida.",
        "answer": "is_valid_url",
        "explanation": "La función is_valid_url en scrap.py verifica si una URL es válida y pertenece al dominio de origen."
    },
    {
        "type": "code",
        "question": "Completa el siguiente fragmento de código para obtener la dirección IP de un host:",
        "code": "import socket\n\nhost = 'www.example.com'\nip = socket.gethostbyname(host)\nprint('Dirección IP:', ___)",
        "answer": "ip",
        "explanation": "La variable 'ip' almacena la dirección IP obtenida mediante socket.gethostbyname(host). Se debe imprimir 'ip'."
    },
    {
        "type": "multiple",
        "question": "¿Qué módulo se utiliza en Python para manejar procesos de manera asíncrona?",
        "options": [
            "subprocess",
            "os",
            "asyncio",
            "threading"
        ],
        "answer": 2,
        "explanation": "El módulo asyncio se utiliza en Python para manejar procesos de manera asíncrona."
    },
    {
        "type": "fill",
        "question": "En el archivo P3.05-DES3-file.py, la función 'encriptar' utiliza el modo _____ de DES3.",
        "answer": "EAX",
        "explanation": "La función 'encriptar' utiliza el modo EAX de DES3 para cifrar los datos."
    },
    {
        "type": "code",
        "question": "En P3.10-tcpclient-datos-with.py, ¿cómo se recibe la respuesta del servidor?",
        "code": "import socket\n\nHOST = '127.0.0.1'\nPORT = 2000\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.connect((HOST, PORT))\n    s.send(b'Hola servidor')\n    data = s.recv(1024)\n    print('Recibido:', ___)",
        "answer": "repr(data)",
        "explanation": "La respuesta del servidor se imprime utilizando repr(data) para mostrar una representación legible de los bytes recibidos."
    },
    {
        "type": "multiple",
        "question": "¿Cuál es el propósito del archivo P4.01-TcpServer-Forever.py?",
        "options": [
            "Implementar un servidor TCP que maneja múltiples clientes de manera indefinida",
            "Crear un cliente TCP que se conecta a un servidor",
            "Listar procesos del sistema",
            "Enviar correos electrónicos usando SMTP"
        ],
        "answer": 0,
        "explanation": "El archivo P4.01-TcpServer-Forever.py implementa un servidor TCP que maneja múltiples clientes de manera indefinida utilizando socketserver."
    },
    {
        "type": "fill",
        "question": "En P5.07-AES-iv.py, el vector de inicialización se genera usando _____ de la biblioteca Crypto.Random.",
        "answer": "os.urandom",
        "explanation": "El vector de inicialización (iv) se genera usando os.urandom(8) de la biblioteca Crypto.Random."
    },
    {
        "type": "code",
        "question": "Completa el siguiente código para crear una clave RSA y exportarla:",
        "code": "from Crypto.PublicKey import RSA\n\nkey = RSA.generate(2048)\nprivate_key = key.export_key()\nwith open('clave_privada.pem', 'wb') as f:\n    f.write(___)",
        "answer": "private_key",
        "explanation": "La clave privada generada se almacena en 'private_key' y debe escribirse en el archivo."
    },
    {
        "type": "multiple",
        "question": "¿Qué hace el archivo P4.18-Ftp-list.py?",
        "options": [
            "Lista los archivos en un servidor FTP",
            "Sube archivos a un servidor FTP",
            "Descarga archivos desde un servidor FTP",
            "Elimina archivos en un servidor FTP"
        ],
        "answer": 0,
        "explanation": "El archivo P4.18-Ftp-list.py se conecta a un servidor FTP y lista los archivos presentes en el directorio."
    },
    {
        "type": "fill",
        "question": "En P2.07-LocalSotrage.py, se utiliza _____ para crear variables locales a cada hilo.",
        "answer": "threading.local()",
        "explanation": "Se utiliza threading.local() para crear variables que son locales a cada hilo, evitando conflictos en el acceso concurrente."
    },
    {
        "type": "code",
        "question": "En P2.15-Join.py, ¿qué hace la función 'join()' en los hilos?",
        "code": "import threading\n\ndef imprime_x(x, n):\n    for _ in range(n):\n        print(x)\n\nt1 = threading.Thread(target=imprime_x, args=('norte', 5))\nt2 = threading.Thread(target=imprime_x, args=('sur', 10))\n\nt1.start()\nt2.start()\n\nt1.___( )\nt2.___( )\n\nprint('Fin!')",
        "answer": "join",
        "explanation": "La función 'join()' espera a que el hilo haya terminado su ejecución antes de continuar."
    },
    {
        "type": "multiple",
        "question": "¿Cuál es la diferencia principal entre Lock y RLock en threading?",
        "options": [
            "Lock puede ser adquirido múltiples veces por el mismo hilo, RLock no",
            "RLock puede ser adquirido múltiples veces por el mismo hilo, Lock no",
            "No hay diferencia, son lo mismo",
            "Lock es recursivo, RLock no"
        ],
        "answer": 1,
        "explanation": "RLock (Reentrant Lock) puede ser adquirido múltiples veces por el mismo hilo sin bloquear, a diferencia de Lock."
    },
    {
        "type": "fill",
        "question": "En P4.25-ApiREST-OpenWeather.py, se utiliza _____ para decodificar la respuesta JSON.",
        "answer": "json.loads",
        "explanation": "Se utiliza json.loads para convertir la cadena JSON en un objeto de Python."
    },
    {
        "type": "code",
        "question": "Completa el siguiente código para enviar un correo electrónico usando SMTP en P4.21-email-smtp.py:",
        "code": "import smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\nbody = '''Hola, este es un correo de prueba.'''\nenviado_por = 'tu_email@example.com'\npassword = 'tu_contraseña'\nto = 'destinatario@example.com'\n\nmensaje = MIMEMultipart()\nmensaje['From'] = enviado_por\nmensaje['To'] = to\nmensaje['Subject'] = 'Prueba'\n\nmensaje.attach(MIMEText(body, 'plain'))\n\ntry:\n    session = smtplib.SMTP('smtp.gmail.com', 587)\n    session.___( )\n    session.login(enviado_por, password)\n    text = mensaje.___()\n    session.sendmail(enviado_por, to, text)\n    session.quit()\n    print('Mensaje enviado')\nexcept:\n    print('Algo fue incorrecto...')",
        "answer": ["starttls()", "as_string"],
        "explanation": "Se debe iniciar la conexión segura con starttls() y convertir el mensaje a cadena con as_string()."
    },
    {
        "type": "multiple",
        "question": "¿Qué hace el archivo P4.26-ConsumirAPIExterna.py?",
        "options": [
            "Envía datos a una API externa",
            "Consume y procesa datos de una API externa",
            "Crea una API externa",
            "Elimina datos de una API externa"
        ],
        "answer": 1,
        "explanation": "El archivo P4.26-ConsumirAPIExterna.py realiza una solicitud a una API externa, recibe y procesa los datos."
    },
    {
        "type": "fill",
        "question": "En P2.19a-Acceso_concurrente_Lock.py, se utiliza _____ para asegurar que solo un hilo acceda a la variable 'g' a la vez.",
        "answer": "lock",
        "explanation": "Se utiliza un objeto Lock llamado 'lock' para asegurar el acceso exclusivo a la variable 'g'."
    },
    {
        "type": "code",
        "question": "Completa el siguiente código para firmar un mensaje usando DSA en P5.13-DSA-firmar.py:",
        "code": "from Crypto.PublicKey import DSA\nfrom Crypto.Signature import DSS\nfrom Crypto.Hash import SHA256\nimport json\n\nf = open('private_key_firma.pem', 'r')\nkey = DSA.import_key(f.read())\n\nmensaje = b'Este es el mensaje a firmar'\nhash_obj = SHA256.new(mensaje)\nfirmador = DSS.new(key, 'fips-186-3')\nfirma = firmador.___(hash_obj)\n\nmensajeFirmado = json.dumps({'mensaje':mensaje.hex(), 'firma':firma.hex()})\nwith open('mensajefirmado.txt', 'w') as f:\n    f.write(mensajeFirmado)",
        "answer": "sign",
        "explanation": "Se utiliza el método 'sign' del objeto 'firmador' para firmar el hash del mensaje."
    },
    {
        "type": "multiple",
        "question": "En P2.25-Productor-consumidor.py, ¿cuál es el tamaño máximo de la cola?",
        "options": [
            "5",
            "10",
            "Unlimited",
            "1"
        ],
        "answer": 1,
        "explanation": "El tamaño máximo de la cola se define como 10 mediante BUF_SIZE = 10."
    },
    {
        "type": "fill",
        "question": "En P4.22-email-imap.py, se utiliza el protocolo _____ para recibir correos electrónicos.",
        "answer": "IMAP",
        "explanation": "El archivo utiliza el protocolo IMAP para conectarse y recibir correos electrónicos."
    },
    {
        "type": "code",
        "question": "Completa el siguiente fragmento para crear y enviar una solicitud GET usando urllib en P4.24-leerUrl.py:",
        "code": "from urllib import request\n\nresponse = request.urlopen('http://www.python.org')\nprint('Código HTTP:', response.___())\nprint('URL:', response.___())\nheaders = response.info()\nprint('Fecha:', headers['date'])\nfor _ in range(5):\n    linea = response.readline().decode('utf-8')\n    print(linea)",
        "answer": ["getcode", "geturl"],
        "explanation": "Para obtener el código HTTP se usa getcode() y para la URL se usa geturl()."
    },
    {
        "type": "multiple",
        "question": "¿Qué hace el archivo P4.10-AdivinaNumeroMulti.py?",
        "options": [
            "Implementa un juego de adivinanza de números para múltiples clientes",
            "Adivina números de forma automática",
            "Genera números aleatorios para pruebas",
            "Implementa un servidor FTP"
        ],
        "answer": 0,
        "explanation": "El archivo P4.10-AdivinaNumeroMulti.py implementa un juego de adivinanza de números que puede manejar múltiples clientes mediante hilos."
    },
    {
        "type": "fill",
        "question": "En P2.07-LocalSotrage.py, cada hilo tiene su propia instancia de _____ para almacenar datos locales.",
        "answer": "threading.local()",
        "explanation": "Se utiliza threading.local() para crear una instancia que almacena datos locales a cada hilo."
    },
    {
        "type": "code",
        "question": "En P2.16a-Acceso_concurrente_Lock.py, ¿qué método se utiliza para adquirir un Lock usando un contexto 'with'?",
        "code": "from threading import Lock\n\ng = 0\nlock = Lock()\n\ndef suma_tres():\n    with ___:\n        a = g\n        time.sleep(0.001)\n        g = a + 3",
        "answer": "lock",
        "explanation": "Dentro del contexto 'with', se coloca el objeto Lock para adquirirlo automáticamente."
    },
    {
        "type": "multiple",
        "question": "¿Cuál es la finalidad del archivo P5.12-Generar-par-claves-RSA.py?",
        "options": [
            "Generar un par de claves RSA pública y privada",
            "Encriptar datos usando RSA",
            "Desencriptar datos usando RSA",
            "Firmar mensajes con RSA"
        ],
        "answer": 0,
        "explanation": "El archivo P5.12-Generar-par-claves-RSA.py genera un par de claves RSA pública y privada y las guarda en archivos."
    },
    {
        "type": "fill",
        "question": "En P2.19a-Acceso_concurrente_Lock.py, se utiliza _____ para asegurar el acceso exclusivo a la variable 'g'.",
        "answer": "lock.acquire()",
        "explanation": "Se llama a lock.acquire() antes de modificar la variable 'g' para asegurar el acceso exclusivo."
    },
    {
        "type": "code",
        "question": "Completa el siguiente código para crear un servidor TCP usando socketserver en P4.01-TcpServer-Forever.py:",
        "code": "import socketserver\n\nclass TCPSocketHandler(socketserver.BaseRequestHandler):\n    def handle(self):\n        self.data = self.request.recv(1024).strip()\n        print(f'Datos recibidos: {self.data.decode()}')\n        self.request.sendall(self.data.upper())\n\nif __name__ == '__main__':\n    HOST, PORT = 'localhost', 2000\n    server = socketserver.TCPServer((HOST, PORT), TCPSocketHandler)\n    try:\n        server.____()\n    except KeyboardInterrupt:\n        print('Servidor finalizado')\n        server.shutdown()",
        "answer": "serve_forever",
        "explanation": "El método 'serve_forever()' mantiene el servidor en ejecución indefinidamente para manejar conexiones."
    },
    {
        "type": "multiple",
        "question": "En P4.03-ClienteTCP.py, ¿qué función se utiliza para recibir datos del servidor?",
        "options": [
            "send",
            "recv",
            "receive",
            "get"
        ],
        "answer": 1,
        "explanation": "Se utiliza la función 'recv' para recibir datos del servidor."
    },
    {
        "type": "fill",
        "question": "En P2.25-Productor-consumidor.py, la clase 'HiloConsumidor' hereda de _____.",
        "answer": "threading.Thread",
        "explanation": "La clase 'HiloConsumidor' hereda de threading.Thread para crear hilos de consumidor."
    },
    {
        "type": "code",
        "question": "Completa el siguiente código para firmar un mensaje usando DSA en P5.13-DSA-firmar.py:",
        "code": "from Crypto.PublicKey import DSA\nfrom Crypto.Signature import DSS\nfrom Crypto.Hash import SHA256\nimport json\n\nf = open('private_key_firma.pem', 'r')\nkey = DSA.import_key(f.read())\n\nmensaje = b'Comprobamos quien firma este mensaje'\nhash_obj = SHA256.new(mensaje)\nfirmador = DSS.new(key, 'fips-186-3')\nfirma = firmador.___(hash_obj)\n\nmensajeFirmado = json.dumps({'mensaje':mensaje.hex(), 'firma':firma.hex()})\nwith open('mensajefirmado.txt', 'w') as f:\n    f.write(mensajeFirmado)",
        "answer": "sign",
        "explanation": "El método 'sign' se utiliza para firmar el hash del mensaje."
    },
    {
        "type": "multiple",
        "question": "¿Qué hace el archivo P2.26-Exception.py?",
        "options": [
            "Demuestra cómo manejar excepciones al iniciar hilos",
            "Crea múltiples hilos sin errores",
            "Lanza excepciones de manera controlada",
            "Finaliza hilos de manera abrupta"
        ],
        "answer": 0,
        "explanation": "El archivo demuestra cómo manejar excepciones al intentar iniciar un hilo que ya está iniciado."
    },
    {
        "type": "fill",
        "question": "En P2.08-Propiedades.py, se cambia el nombre del hilo si su nombre actual es 'miHilo7' usando _____.",
        "answer": "threading.current_thread().name = 'nombre-cambiado'",
        "explanation": "Se utiliza threading.current_thread().name para cambiar el nombre del hilo en ejecución."
    },
    {
        "type": "code",
        "question": "En P5.06-AES.py, completa el código para verificar la integridad del mensaje desencriptado:",
        "code": "from Crypto.Cipher import AES\n\nmensajeOriginal = b'Hola, algoritmo AES'\nkey = b'Clave de 16 Byte'\nprint('Original:', mensajeOriginal)\n\ncipher = AES.new(key, AES.MODE_EAX)\nmensajeCifrado, tag = cipher.encrypt_and_digest(mensajeOriginal)\nprint('Cifrado:', mensajeCifrado)\n\ncipher = AES.new(key, AES.MODE_EAX, nonce=cipher.nonce)\nmensajeDescifrado = cipher.decrypt(mensajeCifrado)\ntry:\n    cipher.___(tag)\n    print('Desencriptado:', mensajeDescifrado)\nexcept ValueError:\n    print('Clave incorrecta o mensaje corrupto')",
        "answer": "verify",
        "explanation": "El método 'verify' se utiliza para verificar la integridad del mensaje desencriptado."
    },
    {
        "type": "multiple",
        "question": "¿Cuál es el propósito del archivo P4.11-PPTServidorBase.py?",
        "options": [
            "Implementar un servidor básico para el juego Piedra-Papel-Tijera",
            "Crear un cliente para el juego Piedra-Papel-Tijera",
            "Listar procesos del sistema",
            "Enviar y recibir correos electrónicos"
        ],
        "answer": 0,
        "explanation": "El archivo P4.11-PPTServidorBase.py implementa un servidor básico para gestionar el juego Piedra-Papel-Tijera entre dos jugadores."
    },
    {
        "type": "multiple",
        "question": "¿Qué es el módulo 'socket'?",
        "options": [
            "Un módulo de Python que permite crear servidores y clientes",
            "Un módulo de Python que permite enviar y recibir correos electrónicos",
            "Un módulo de Python que permite gestionar procesos del sistema",
            "Un módulo de Python que permite crear una interfaz gráfica"
        ],
        "answer": 0,
        "explanation": "El módulo 'socket' es un módulo de Python que permite crear servidores y clientes."
    }
]